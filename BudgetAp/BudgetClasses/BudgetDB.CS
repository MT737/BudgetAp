using System;
using System.Collections.Generic;
using System.Linq;
using System.Data.Linq.Mapping;
using System.Text;
using System.Threading.Tasks;
using System.IO;
using System.Data.Linq;
using System.Configuration;
using static BudgetAp.DatabaseInsertsAndMods;
using static BudgetAp.Utils;
using System.Data.SqlClient;
using System.Windows.Forms;
using System.Text.RegularExpressions;
using System.Security.Cryptography;
using System.Runtime.CompilerServices;
using BudgetAp.BudgetClasses.HelperBudgetClasses;

namespace BudgetAp.BudgetClasses
{
    public class BudgetDB
    {
        private DataContext db = new DataContext(ConfigurationManager.ConnectionStrings["BudgetConnect"].ConnectionString);
        private string backupLocation = "";
        private Table<Account> Accounts;
        private Table<Category> Categories;
        private Table<Vendor> Vendors;
        private Table<Transactions> Transactions;

        /// <summary>
        /// Budget class constructor.
        /// </summary>
        /// <param name="pathway">String: save location for the .bak file.</param>
        public BudgetDB(string pathway)
        {
            backupLocation = pathway;
            Accounts = db.GetTable<Account>();
            Categories = db.GetTable<Category>();
            Vendors = db.GetTable<Vendor>();
            Transactions = db.GetTable<Transactions>();

            if (Vendors.Count() == 0 && Categories.Count() == 0)
            {
                InsertDefaults();
            }
        }

        /// <summary>
        /// Provides the backup file location.
        /// </summary>
        /// <returns>String: backup file pathway.</returns>
        public string GetBackupLocation()
        {
            return backupLocation;
        }

        /// <summary>
        /// Inserts the default values for Vendors and Categories. Lists are found in the associated .txt files.
        /// </summary>
        private void InsertDefaults()
        {
            //Default vendors
            foreach (string item in GetListOfNames("vendor"))
            {
                AddVendor(Vendors, item, true);
            }

            //Default categories
            foreach (string item in GetListOfNames("category"))
            {
                AddCategory(Categories, item, true);
            }

            //Before submiting changes the vendor and cateogry object tables are not synced with the primary database. 
            db.SubmitChanges();
        }

        public bool IsSuccessfulNewAccount(string name, decimal balance, bool isAsset, bool isActive)
        {
            int accountID;

            //Confirm account doesn't already exist.
            if (AccountExists(name))
            {
                MessageBox.Show("Account already exists. Please modify the existing account or create a new account.", "New Account", MessageBoxButtons.OK, MessageBoxIcon.Information);
                return false;
            }

            //Add acount to account object
            AddAccount(Accounts, name, isAsset, isActive);

            //Submit to DB (IDs are auto generated by the DB upon submission of object level changes. Account ID is needed to insert the transaction.
            PushToDBandBackup();

            //Pull the newly created account ID          
            try
            {
                accountID = GetAccountID(name);
            }
            catch (InvalidOperationException exInvalid)
            {
                MessageBox.Show("Erorr! Account duplication in the database.");
                MessageBox.Show(exInvalid.ToString(), "New Account", MessageBoxButtons.OK, MessageBoxIcon.Information);
                return false; //TODO: confirm the return is necessary (i.e., does catching the exception end the program?)
            }
            catch (ArgumentNullException exNull)
            {
                MessageBox.Show("Error! Account not saved to the database.");
                MessageBox.Show(exNull.ToString(), "New Account", MessageBoxButtons.OK, MessageBoxIcon.Information);
                return false; //TODO: confirm the return is necessary (i.e., does catching the exception end the program?)
            }

            //Add a new account transaction.
            InsertTransaction(Transactions, DateTime.Now, accountID, GetNewAccountTransType(accountID), GetCategoryID("New Account Balance"), GetVendorID("N/A"), balance, "New Account");

            //Submit transaction to the DB.
            PushToDBandBackup();

            return true;
        }

        public void PushToDBandBackup()
        {
            db.SubmitChanges();
            SaveCurrentBudget(this);           
        }

        internal bool IsSuccessfulAccountModification(string selectedAcccountName, string updatedAccountName, decimal updatedAccountBalance, bool UpdatedAccountIsAsset, bool UpdatedAccountIsActive)
        {
            int selectedAccountID = GetAccountID(selectedAcccountName);
            bool nameNotChanged = selectedAcccountName == updatedAccountName;
            bool balanceNotChanged = GetAccountBalance(selectedAccountID) == updatedAccountBalance;
            bool classificationNotChanged = AccountIsAsset(selectedAccountID) == UpdatedAccountIsAsset;
            bool statusNotChanged = AccountIsActive(selectedAccountID) == UpdatedAccountIsActive;

            if (nameNotChanged && balanceNotChanged && classificationNotChanged && statusNotChanged)
            {
                MessageBox.Show("No change detected. Please check your inputs.");
                return false;
            }

            if (!balanceNotChanged)
            {
                //TODO: Allow user to add comments to the description field detailing the reason for the balance adjustment.

                //Add new transaction using the accountAdjustment to the transactions table. All subsequent account balance determinations reflect the updated account balance.
                decimal accountAdjustment = updatedAccountBalance - GetAccountBalance(selectedAccountID);                
                InsertTransaction(Transactions, DateTime.Now, selectedAccountID, GetNewAccountTransType(selectedAccountID), GetCategoryID("Account Balance Modification")
                    , GetVendorID("N/A"), accountAdjustment, "Account Balance Modification");                
            }

            if (!nameNotChanged || !classificationNotChanged || !statusNotChanged)
            {
                //Implement modification of the account in the accounts table.
                ModifyAccount(Accounts, selectedAccountID, updatedAccountName, UpdatedAccountIsAsset, UpdatedAccountIsActive);                
            }

            //Submit all changes to the DB.
            db.SubmitChanges();
            return true;
        }

        public Table<Transactions> GetTransactionsTable()
        {
            return Transactions;
        }

        public void LoadTransactionsComboBoxes(ComboBox transType, ComboBox account, ComboBox transferAccount, ComboBox categories, ComboBox vendors)
        {
            transType.DataSource = GetTransactionTypes();
            account.DataSource = GetListOfAccounts();
            transferAccount.DataSource = GetListOfAccounts();
            categories.DataSource = GetCategoryNameList();
            vendors.DataSource = GetVendorNameList();
        }

        public void LoadTransaction(int transID, ComboBox transType, ComboBox account, ComboBox categories, ComboBox vendors, TextBox amount, DateTimePicker date, TextBox description)
        {
            TransactionsWithNames transaction = GetTransaction(transID);
             
            transType.SelectedIndex = transType.FindStringExact(transaction.TransactionType);
            account.SelectedIndex = account.FindStringExact(transaction.Account);
            amount.Text = transaction.Amount.ToString();
            date.Value = transaction.TransactionDate;
            categories.SelectedIndex = categories.FindStringExact(transaction.Category);
            vendors.SelectedIndex = vendors.FindStringExact(transaction.Vendor);
            description.Text = transaction.Description;
        }

        private TransactionsWithNames GetTransaction(int transID)
        {
            TransactionsWithNames transaction = new TransactionsWithNames();
            IQueryable<Transactions> transactionQuery =
                from trans in Transactions
                where trans.TransactionID == transID
                select trans;

            foreach (Transactions trans in transactionQuery)
            {
                transaction.TransactionID = trans.TransactionID;
                transaction.TransactionType = trans.TransactionType;
                transaction.Account = GetAccountName(trans.AccountID);
                transaction.Amount = trans.Amount;
                transaction.TransactionDate = trans.TransactionDate;
                transaction.Category = GetCategoryName(trans.CategoryID);
                transaction.Vendor = GetVendorName(trans.VendorID);
                transaction.Description = trans.Description;
            }
            
            return transaction;
        }

        public int GetAccountCount()
        {
            IQueryable<Account> accountCount =
                from acct in Accounts
                select acct;
            return accountCount.Count();
        }

        private string GetAccountName(int accountID)
        {
            IQueryable<Account> account =
                from acct in Accounts
                where acct.AccountID == accountID
                select acct;
            return account.Single().Name;
        }

        public int GetAccountID(string accountName)
        {
            IQueryable<Account> account =
                from acct in Accounts
                where acct.Name == accountName
                select acct;
            return account.Single().AccountID;
        }

        private string GetNewAccountTransType(int accountID)
        {
            string transType;

            if (AccountIsAsset(accountID))
            {
                transType = "Payment To";
            }
            else
            {
                transType = "Payment From";
            }

            return transType;
        }

        private string[] GetTransactionTypes()
        {
            string[] types = new string[] { "Payment From", "Payment To" };
            return types;            
        }

        private bool AccountIsAsset(int accountID)
        {
            IQueryable<Account> account =
                from acct in Accounts
                where acct.AccountID == accountID
                select acct;
            return account.Single().IsAsset;
        }

        private bool AccountIsActive(int accountID)
        {
            IQueryable<Account> account =
                from acct in Accounts
                where acct.AccountID == accountID
                select acct;
            return account.Single().IsActive;
        }

        private bool AccountExists(string accountName)
        {
            List<string> dbNames = new List<string>();
            IQueryable<Account> nameCheckQuery =
                from acct in Accounts
                select acct;

            foreach (Account item in nameCheckQuery)
            {
                dbNames.Add(Regex.Replace(item.Name, "[^A-Za-z0-9]", "").ToUpper().Trim());
            }

            foreach (string formattedName in dbNames)
            {
                if (formattedName == Regex.Replace(accountName, "[^A-Za-z0-9]", "").ToUpper().Trim())
                {
                    return true;
                }
            }

            //If still in the method, then the account is new.
            return false;
        }

        private decimal GetAccountBalance(int accountID)
        {
            //TODO: clean this up with a better use of LINQ (keep running into an issue with converting NULL to decimal (which shouldn't happen here anyways?).
            decimal from = 0;
            decimal to = 0;

            //Get total payments from the account.
            var accountBalanceFrom =
                  from trans in Transactions
                  where trans.AccountID == accountID && trans.TransactionType == "Payment From"
                  select trans;

            foreach (var account in accountBalanceFrom)
            {
                from += account.Amount;
            }

            //Get total payments to the account.
            var accountBalanceTo =
                from trans in Transactions
                where trans.AccountID == accountID && trans.TransactionType == "Payment To"
                select trans;

            foreach (var account in accountBalanceTo)
            {
                to += account.Amount;
            }

            //Determine asset status
            if (AccountIsAsset(accountID))
            {
                //Asset account balance is the sum of total payments to less payments from.
                return to - from;
            }
            else
            {
                //Liability account balance is the sum of payments from (i.e., credit to the holder) less payments to (i.e., paying down debt).
                return from - to;
            }
        }

        private List<string> GetListOfAccounts()
        {
            List<string> accountsList = new List<string>();
            IQueryable<Account> accounts =
                from acct in Accounts
                select acct;

            foreach (Account item in accounts)
            {
                accountsList.Add(item.Name);
            }

            return accountsList;
        }

        private List<AccountWithBalance> GetAccountListWithBalance()
        {
            List<AccountWithBalance> accountList = new List<AccountWithBalance>();
            IQueryable<Account> accounts =
                from acct in Accounts
                select acct;

            foreach (Account item in accounts)
            {
                AccountWithBalance accountItem = new AccountWithBalance();
                accountItem.AccountID = item.AccountID;
                accountItem.Name = item.Name;
                accountItem.IsAsset = item.IsAsset;
                accountItem.IsActive = item.IsActive;
                accountItem.Balance = GetAccountBalance(item.AccountID);
                accountList.Add(accountItem);
            }

            return accountList;
        }

        private string GetCategoryName(int categoryID)
        {
            IQueryable<Category> categoryQuery =
                from cats in Categories
                where cats.CategoryID == categoryID
                select cats;
            return categoryQuery.Single().Name;
        }

        public int GetCategoryID(string categoryName)
        {
            IQueryable<Category> category =
                from cat in Categories
                where cat.Name == categoryName
                select cat;
            return category.Single().CategoryID;

            //TODO: Try catch? Necessary? Shouldn't be if I'm propery catching during the insert phase.
        }

        private List<string> GetCategoryNameList()
        {
            List<string> categories = new List<string>();

            IQueryable<Category> categoryQuery =
                from cats in Categories
                select cats;

            foreach (Category item in categoryQuery)
            {
                categories.Add(item.Name);
            }

            return categories;
        }        

        public Table<Category> GetCategoryTable()
        {
            return Categories;
        }

        private object GetVendorNameList()
        {
            List<string> vendors = new List<string>();

            IQueryable<Vendor> vendorQuery =
                from vend in Vendors
                select vend;

            foreach (Vendor item in vendorQuery)
            {
                vendors.Add(item.Name);
            }

            return vendors;
        }
     
        private string GetVendorName(int vendorID)
        {
            IQueryable<Vendor> vendorQuery =
                from vend in Vendors
                where vend.VendorID == vendorID
                select vend;
            return vendorQuery.Single().Name;
        }

        public bool NameExists(string catOrVend, string name)
        {
            //Get a list of names from the appropriate table.
            List<string> names = new List<string>();
            if (catOrVend == "Category")
            {

                IQueryable<Vendor> nameCheckQuery =
                    from vends in Vendors
                    select vends;

                foreach (Vendor vend in nameCheckQuery)
                {
                    names.Add(Regex.Replace(vend.Name, "[^A-Za-z0-9]", "").ToUpper().Trim());
                }

            }
            else
            {
                IQueryable<Category> nameCheckQuery =
                    from cats in Categories
                    select cats;

                foreach (Category cats in nameCheckQuery)
                {
                    names.Add(Regex.Replace(cats.Name, "[^A-Za-z0-9]", "").ToUpper().Trim());
                }
            }

            //Compare the list to the new name.
            foreach (string formattedName in names)
            {
                if (formattedName == Regex.Replace(name, "[^A-Za-z0-9]", "").ToUpper().Trim())
                {
                    MessageBox.Show("Name already exists.");
                    return true;
                }
            }

            //If still in the method, then the name is new.
            return false;
        }

        public int GetVendorID(string vendorName)
        {
            IQueryable<Vendor> vendor =
                from vend in Vendors
                where vend.Name == vendorName
                select vend;
            return vendor.Single().VendorID;

            //TODO: Try catch? Necessary? Shouldn't be if I'm propery catching during the insert phase.
        }

        public Table<Vendor> GetVendorTable()
        {
            return Vendors;
        }

        public void FillTransactionsDGV(DataGridView dgvTransactions)
        {
            dgvTransactions.DataSource = GetTransactionsList();
            dgvTransactions.AutoGenerateColumns = true;
        }

        public void FillAccountDGV(DataGridView dgvAccounts)
        {
            //TODO: data binding, would that be the better choice?            
            dgvAccounts.DataSource = GetAccountListWithBalance();

            //TODO: consider other formatting.
            dgvAccounts.AutoGenerateColumns = true;
        }

        public void FillEditSelectionDGV(DataGridView dgvSelectionList, string catOrVend)
        {
            if (catOrVend == "Category")
            {
                List<Category> categories = new List<Category>();
                IQueryable<Category> categoriesQuery =
                    from cats in Categories
                    select cats;

                foreach (Category cat in categoriesQuery)
                {
                    Category nextCat = new Category();
                    nextCat.Name = cat.Name;
                    nextCat.IsDefault = cat.IsDefault;
                    categories.Add(nextCat);
                }
                
                dgvSelectionList.DataSource = categories;
            }
            else
            {
                List<Vendor> vendors = new List<Vendor>();
                IQueryable<Vendor> vendorsQuery =
                    from vends in Vendors
                    select vends;

                foreach (Vendor vend in vendorsQuery)
                {
                    Vendor nextVend = new Vendor();
                    nextVend.Name = vend.Name;
                    nextVend.IsDefault = vend.IsDefault;
                    vendors.Add(nextVend);
                }

                dgvSelectionList.DataSource = vendors;
            }

            dgvSelectionList.AutoGenerateColumns = true;
        }

        internal void FillSpendingByCategory(DataGridView dgvSpendingByCategory)
        {
            dgvSpendingByCategory.DataSource = GetSpendingByCategory();            
            dgvSpendingByCategory.AutoGenerateColumns = true;
        }

        private List<TransactionsWithNames> GetTransactionsList()
        {
            List<TransactionsWithNames> transactions = new List<TransactionsWithNames>();
            IQueryable<Transactions> transactionsQuery =
                from trans in Transactions
                select trans;

            foreach (Transactions item in transactionsQuery)
            {
                TransactionsWithNames itemToAdd = new TransactionsWithNames();
                itemToAdd.TransactionID = item.TransactionID;
                itemToAdd.TransactionDate = item.TransactionDate;
                itemToAdd.TransactionType = item.TransactionType;
                itemToAdd.Account = GetAccountName(item.AccountID);
                itemToAdd.Amount = item.Amount;
                itemToAdd.Category = GetCategoryName(item.CategoryID);
                itemToAdd.Vendor = GetVendorName(item.VendorID);
                itemToAdd.Description = item.Description;
                transactions.Add(itemToAdd);
            }
            return transactions;
        }

        private List<SpendingByCategory> GetSpendingByCategory()
        {
            List<SpendingByCategory> categorySpending = new List<SpendingByCategory>();
            List<string> categories = GetCategoryNameList();

            foreach (string category in categories)
            {
                SpendingByCategory categoryToAdd = new SpendingByCategory();
                categoryToAdd.CategoryID = GetCategoryID(category);
                categoryToAdd.Name = category;
                categoryToAdd.PriorMonth = GetCategoryTotal(categoryToAdd.CategoryID, DateTime.Now.AddMonths(-1));
                categoryToAdd.CurrentMonth = GetCategoryTotal(categoryToAdd.CategoryID, DateTime.Now);
                categoryToAdd.ThreeMonthAverage = GetCategoryThreeMonthAverage(categoryToAdd.CategoryID, DateTime.Now);
                categorySpending.Add(categoryToAdd);
            }
            return categorySpending;
        }

        private decimal GetCategoryTotal(int categoryID, DateTime timeSpan)
        {
            decimal total = 0;

            var categorySumQuery =
                from trans in Transactions
                where trans.CategoryID == categoryID && trans.TransactionDate.Month == timeSpan.Month && trans.TransactionDate.Year == timeSpan.Year
                select trans;

            foreach (var item in categorySumQuery)
            {
                total += item.Amount;
            }

            return total;
        }

        private decimal GetCategoryThreeMonthAverage(int categoryID, DateTime currentDate)
        {
            decimal total = 0;

            var categorySumQuery =
                from trans in Transactions
                where trans.CategoryID == categoryID && (
                    trans.TransactionDate.Month == (currentDate.AddMonths(-1).Month) && (trans.TransactionDate.Year == currentDate.AddMonths(-1).Year)                
                    || trans.TransactionDate.Month == (currentDate.AddMonths(-2).Month) && (trans.TransactionDate.Year == currentDate.AddMonths(-2).Year)
                    || trans.TransactionDate.Month == (currentDate.AddMonths(-3).Month) && (trans.TransactionDate.Year == currentDate.AddMonths(-3).Year)
                )
                select trans;

            foreach (var item in categorySumQuery)
            {
                total += item.Amount;
            }

            return total/3;
        }
    }
}
