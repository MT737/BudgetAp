using BudgetAp.BudgetClasses.HelperBudgetClasses;
using System;
using System.Collections.Generic;
using System.Data.Linq;
using System.Linq;
using System.Text.RegularExpressions;
using System.Windows.Forms;
using static BudgetAp.DatabaseInsertsAndMods;
using static BudgetAp.Utils;

namespace BudgetAp.BudgetClasses
{
    public class BudgetDB
    {
        private string _conn;
        private string _backupPathway;
        private DataContext db;      
        private Table<Account> Accounts;
        private Table<Category> Categories;
        private Table<Vendor> Vendors;
        private Table<Transactions> Transactions;
        
        /// <summary>
        /// Budget class constructor.
        /// </summary>
        /// <param name="backupPathway">String: save location for the .bak file.</param>
        /// <param name="connString">String: DB connection string.</param>
        public BudgetDB(string backupPathway, string connString)
        {
            _backupPathway = backupPathway;
            _conn = connString;
            db = new DataContext(_conn);
            Accounts = db.GetTable<Account>();
            Categories = db.GetTable<Category>();
            Vendors = db.GetTable<Vendor>();
            Transactions = db.GetTable<Transactions>();

            if (Vendors.Count() == 0 && Categories.Count() == 0)
            {
                InsertDefaults();
            }
        }

        /// <summary>
        /// Provides the backup file location.
        /// </summary>
        /// <returns>String: backup file pathway.</returns>
        public string GetBackupLocation()
        {
            return _backupPathway;
        }

        /// <summary>
        /// Provides the DB connection string.
        /// </summary>
        /// <returns>String: DB connections string.</returns>
        public string GetConnectionString()
        {
            return _conn;
        }

        /// <summary>
        /// Inserts the default values for Vendors and Categories. Lists are found in the associated .txt files.
        /// </summary>
        private void InsertDefaults()
        {
            //Default vendors
            foreach (string item in GetListOfNames("vendor"))
            {
                AddVendor(Vendors, item, true);
            }

            //Default categories
            foreach (string item in GetListOfNames("category"))
            {

                AddCategory(Categories, item, true, true);
            }

            //Submit the changes to the DB. 
            db.SubmitChanges();
        }

        /// <summary>
        /// Inserts a new account row into the database.
        /// </summary>
        /// <param name="name">String: name of the new account.</param>
        /// <param name="balance">Decimal: new account balance.</param>
        /// <param name="isAsset">Bool: indication of account classification. True = asset, false = liability.</param>
        /// <param name="isActive">Bool: indication of account status. True = active, false = inactive.</param>
        /// <returns>True if new account is successfully added to the DB. False if the account already exists or on exception trigger.</returns>
        public bool IsSuccessfulNewAccount(string name, decimal balance, bool isAsset, bool isActive)
        {
            int accountID;

            //Confirm account doesn't already exist.
            if (AccountExists(name))
            {
                MessageBox.Show("Account already exists. Please modify the existing account or create a new account.", "New Account", MessageBoxButtons.OK, MessageBoxIcon.Information);
                return false;
            }

            //Add acount to account object
            AddAccount(Accounts, name, isAsset, isActive);

            //Submit to DB (IDs are auto generated by the DB upon submission of object level changes. Account ID is needed to insert the transaction.
            PushToDBandBackup();

            //Pull the newly created account ID          
            try
            {
                accountID = GetAccountID(name);
            }
            catch (InvalidOperationException exInvalid)
            {
                MessageBox.Show($"Erorr! Account duplication in the database. {exInvalid}", "BudgetApp", MessageBoxButtons.OK);
                return false;
            }
            catch (ArgumentNullException exNull)
            {
                MessageBox.Show($"Error! Account not saved to the database. {exNull}", "BudgetApp", MessageBoxButtons.OK);
                return false;
            }

            //Add a new account transaction.
            InsertTransaction(Transactions, DateTime.Now, accountID, GetNewAccountTransType(accountID), GetCategoryID("New Account Balance"), GetVendorID("N/A"), balance, "New Account");

            //Submit transaction to the DB.
            PushToDBandBackup();

            return true;
        }

        /// <summary>
        /// Calls the database submit changes method followed by the SaveCurrentBudget method.
        /// </summary>
        public void PushToDBandBackup()
        {
            db.SubmitChanges();
            SaveCurrentBudget(this);           
        }

        /// <summary>
        /// Modifies the fields of a currently exist account.
        /// </summary>
        /// <param name="selectedAcccountName">String: name of the account to be modified. Used to pull current account field data for comparison to updated values.</param>
        /// <param name="updatedAccountName">String: name of the updated account.</param>
        /// <param name="updatedAccountBalance">Decimal: updated balance.</param>
        /// <param name="UpdatedAccountIsAsset">Bool: updated account classification.</param>
        /// <param name="UpdatedAccountIsActive">Bool: updated account status.</param>
        /// <returns>Bool: True if account is successfully modified. False if no changes are detected.</returns>
        internal bool IsSuccessfulAccountModification(string selectedAcccountName, string updatedAccountName, decimal updatedAccountBalance, bool UpdatedAccountIsAsset, bool UpdatedAccountIsActive)
        {
            //Get the account name
            int selectedAccountID = GetAccountID(selectedAcccountName);
            
            //Test if name, balance, classification, or status have changed.
            bool nameNotChanged = selectedAcccountName == updatedAccountName;                        
            bool balanceNotChanged = GetAccountBalance(selectedAccountID) == updatedAccountBalance;
            bool classificationNotChanged = AccountIsAsset(selectedAccountID) == UpdatedAccountIsAsset;
            bool statusNotChanged = AccountIsActive(selectedAccountID) == UpdatedAccountIsActive;

            //If nothing has changed, alert the user and hald the process (return false).
            if (nameNotChanged && balanceNotChanged && classificationNotChanged && statusNotChanged)
            {
                MessageBox.Show("No change detected. Please check your inputs.");
                return false;
            }

            //Test for balance change.
            if (!balanceNotChanged)
            {
                //Add new transaction using the accountAdjustment to the transactions table. All subsequent account balance determinations reflect the updated account balance.
                decimal accountAdjustment = updatedAccountBalance - GetAccountBalance(selectedAccountID);                
                InsertTransaction(Transactions, DateTime.Now, selectedAccountID, GetNewAccountTransType(selectedAccountID), GetCategoryID("Account Balance Modification")
                    , GetVendorID("N/A"), accountAdjustment, "Account Balance Modification");                
            }

            //Test for non-balance changes.
            if (!nameNotChanged || !classificationNotChanged || !statusNotChanged)
            {
                //Implement modification of the account in the accounts table.
                ModifyAccount(Accounts, selectedAccountID, updatedAccountName, UpdatedAccountIsAsset, UpdatedAccountIsActive);                
            }

            //Submit all changes to the DB.
            db.SubmitChanges();
            return true;
        }

        /// <summary>
        /// Gets the transactions table for the budget object that calls the method.
        /// </summary>
        /// <returns>Table Transactions</returns>
        public Table<Transactions> GetTransactionsTable()
        {
            return Transactions;
        }

        /// <summary>
        /// Fills data source elements of the TransactionsManager comboboxes.
        /// </summary>
        /// <param name="transType">Combobox: transaction types combobox.</param>
        /// <param name="account">Combobox: account list combobox.</param>
        /// <param name="transferAccount">Combobox: transfer account list combobox.</param>
        /// <param name="categories">Combobox: categories list combobox.</param>
        /// <param name="vendors">Combobox: vendors list combobox.</param>
        public void LoadTransactionsComboBoxes(ComboBox transType, ComboBox account, ComboBox transferAccount, ComboBox categories, ComboBox vendors)
        {
            transType.DataSource = GetTransactionTypes();
            account.DataSource = GetListOfAccounts();
            transferAccount.DataSource = GetListOfAccounts();
            categories.DataSource = GetCategoryNameList();
            vendors.DataSource = GetVendorNameList();
        }

        /// <summary>
        /// Sets the TransactionManager form values equal to the field values of a specified transaction.
        /// </summary>
        /// <param name="transID">Int: transaction ID representing the transaction from which to pull field values.</param>
        /// <param name="transType">Combobox: transaction type combobox.</param>
        /// <param name="account">Combobox: account list combobox.</param>
        /// <param name="categories">Combobox: categories list combobox.</param>
        /// <param name="vendors">Combobox: vendors list combobox.</param>
        /// <param name="amount">TextBox: amount text box.</param>
        /// <param name="date">DateTimePicker.</param>
        /// <param name="description">TextBox: description.</param>
        public void LoadTransaction(int transID, ComboBox transType, ComboBox account, ComboBox categories, ComboBox vendors, TextBox amount, DateTimePicker date, TextBox description)
        {
            TransactionsWithNames transaction = GetTransaction(transID);
             
            transType.SelectedIndex = transType.FindStringExact(transaction.TransactionType);
            account.SelectedIndex = account.FindStringExact(transaction.Account);
            amount.Text = transaction.Amount.ToString();
            date.Value = transaction.TransactionDate;
            categories.SelectedIndex = categories.FindStringExact(transaction.Category);
            vendors.SelectedIndex = vendors.FindStringExact(transaction.Vendor);
            description.Text = transaction.Description;
        }

        /// <summary>
        /// Creates and returns a TransactionsWithNames object based on the passed transaction ID.
        /// </summary>
        /// <param name="transID">Int: transaction ID for which transaction field data will be used to generate the TransactionsWithNames object.</param>
        /// <returns>TransactionsWithNames object filled with data matching the passed transaction ID.</returns>
        private TransactionsWithNames GetTransaction(int transID)
        {
            TransactionsWithNames transaction = new TransactionsWithNames();
            IQueryable<Transactions> transactionQuery =
                from trans in Transactions
                where trans.TransactionID == transID
                select trans;

            foreach (Transactions trans in transactionQuery)
            {
                transaction.TransactionID = trans.TransactionID;
                transaction.TransactionType = trans.TransactionType;
                transaction.Account = GetAccountName(trans.AccountID);
                transaction.Amount = trans.Amount;
                transaction.TransactionDate = trans.TransactionDate;
                transaction.Category = GetCategoryName(trans.CategoryID);
                transaction.Vendor = GetVendorName(trans.VendorID);
                transaction.Description = trans.Description;
            }
            
            return transaction;
        }

        /// <summary>
        /// Gets a count of the accounts in the budget object that calls the method.
        /// </summary>
        /// <returns>Int: number of accounts in the budget that calls the method.</returns>
        public int GetAccountCount()
        {
            IQueryable<Account> accountCount =
                from acct in Accounts
                select acct;
            return accountCount.Count();
        }

        /// <summary>
        /// Gets the account name associated to the account ID parameter.
        /// </summary>
        /// <param name="accountID">Int: account ID for which to pull account name.</param>
        /// <returns>String: account name associated to the account ID.</returns>
        private string GetAccountName(int accountID)
        {
            IQueryable<Account> account =
                from acct in Accounts
                where acct.AccountID == accountID
                select acct;
            return account.Single().Name;
        }

        /// <summary>
        /// Gets the account ID associated to the accountName parameter.
        /// </summary>
        /// <param name="accountName">String: account name for which to pull an account ID.</param>
        /// <returns>Int: account ID associated to the account name.</returns>
        public int GetAccountID(string accountName)
        {
            IQueryable<Account> account =
                from acct in Accounts
                where acct.Name == accountName
                select acct;
            return account.Single().AccountID;
        }

        /// <summary>
        /// Gets the appropriate new account transaction type based on the new account's classification.
        /// </summary>
        /// <param name="accountID">Int: account ID for which to determine the correct new account transaction type.</param>
        /// <returns>String: transaction type appropriate to the new account transaction. "Payment To" for new asset accounts. "Payment From" for new liability accounts.</returns>
        private string GetNewAccountTransType(int accountID)
        {
            string transType;

            if (AccountIsAsset(accountID))
            {
                transType = "Payment To";
            }
            else
            {
                transType = "Payment From";
            }

            return transType;
        }

        /// <summary>
        /// Gets a string array consisting of the two different transaction types.
        /// </summary>
        /// <returns>String[] consisting of the two different transaction types ("Payment From" and "Payment To").</returns>
        private string[] GetTransactionTypes()
        {
            string[] types = new string[] { "Payment From", "Payment To" };
            return types;            
        }

        /// <summary>
        /// Infers a given account's classification.
        /// </summary>
        /// <param name="accountID">Int: account ID for which to determine classification.</param>
        /// <returns>Bool: True if account is an asset. False if an account is a liability.</returns>
        private bool AccountIsAsset(int accountID)
        {
            IQueryable<Account> account =
                from acct in Accounts
                where acct.AccountID == accountID
                select acct;
            return account.Single().IsAsset;
        }

        /// <summary>
        /// Infers a given account's status.
        /// </summary>
        /// <param name="accountID">Int: account ID for which to determine classification.</param>
        /// <returns>Bool: True if account is active. False if account is inactive.</returns>
        private bool AccountIsActive(int accountID)
        {
            IQueryable<Account> account =
                from acct in Accounts
                where acct.AccountID == accountID
                select acct;
            return account.Single().IsActive;
        }

        /// <summary>
        /// Infers the existence of a specified account by comparing the string parameter representing an account name to all currently existing account names.
        /// </summary>
        /// <param name="accountName">String: account name to compare to all currently existing account names.</param>
        /// <returns>Bool: True if account name found in the database. False if account name not found in the database.</returns>
        private bool AccountExists(string accountName)
        {
            List<string> dbNames = new List<string>();
            IQueryable<Account> nameCheckQuery =
                from acct in Accounts
                select acct;

            foreach (Account item in nameCheckQuery)
            {
                dbNames.Add(Regex.Replace(item.Name, "[^A-Za-z0-9]", "").ToUpper().Trim());
            }

            foreach (string formattedName in dbNames)
            {
                if (formattedName == Regex.Replace(accountName, "[^A-Za-z0-9]", "").ToUpper().Trim())
                {
                    return true;
                }
            }

            //If still in the method, then the account is new.
            return false;
        }

        /// <summary>
        /// Calculates and returns the balance for the account specified in the accountID parameter.
        /// </summary>
        /// <param name="accountID">Int: account ID for which to determine the current balance.</param>
        /// <returns>Decimal: balance for the specified account.</returns>
        private decimal GetAccountBalance(int accountID)
        {
            decimal from = 0;
            decimal to = 0;

            //Get total payments from the account.
            var accountBalanceFrom =
                  from trans in Transactions
                  where trans.AccountID == accountID && trans.TransactionType == "Payment From"
                  select trans;
            
            //TODO: Research a better means for aggregation.
            foreach (var account in accountBalanceFrom)
            {
                from += account.Amount;
            }

            //Get total payments to the account.
            var accountBalanceTo =
                from trans in Transactions
                where trans.AccountID == accountID && trans.TransactionType == "Payment To"
                select trans;

            foreach (var account in accountBalanceTo)
            {
                to += account.Amount;
            }

            //Determine asset status
            if (AccountIsAsset(accountID))
            {
                //Asset account balance is the sum of total payments to less payments from.
                return to - from;
            }
            else
            {
                //Liability account balance is the sum of payments from (i.e., credit to the holder) less payments to (i.e., paying down debt).
                return from - to;
            }
        }

        /// <summary>
        /// Gets a list of strings representing account names in the budget object that calls the method.
        /// </summary>
        /// <returns>List of string: each string represents a unique account name from the calling budget object.</returns>
        private List<string> GetListOfAccounts()
        {
            List<string> accountsList = new List<string>();
            IQueryable<Account> accounts =
                from acct in Accounts
                select acct;

            foreach (Account item in accounts)
            {
                accountsList.Add(item.Name);
            }

            return accountsList;
        }

        /// <summary>
        /// Gets a list of AccountWithBalance objects derived from the calling budget object. Each AccountWithBalance object is filled with data for a unique account.
        /// </summary>
        /// <returns>List of AccountWithBalance objects derived from the calling budget object. Each AccountWithBalance object is filled with data for a unique account.</returns>
        private List<AccountWithBalance> GetAccountListWithBalance()
        {
            List<AccountWithBalance> accountList = new List<AccountWithBalance>();
            IQueryable<Account> accounts =
                from acct in Accounts
                select acct;

            foreach (Account item in accounts)
            {
                AccountWithBalance accountItem = new AccountWithBalance();
                accountItem.AccountID = item.AccountID;
                accountItem.Name = item.Name;
                accountItem.IsAsset = item.IsAsset;
                accountItem.IsActive = item.IsActive;
                accountItem.Balance = GetAccountBalance(item.AccountID);
                accountList.Add(accountItem);
            }

            return accountList;
        }

        /// <summary>
        /// Gets the name of a category based on the passed category ID.
        /// </summary>
        /// <param name="categoryID">Int: category ID for which to pull the category name.</param>
        /// <returns>String: name of the category for the specified category ID.</returns>
        private string GetCategoryName(int categoryID)
        {
            IQueryable<Category> categoryQuery =
                from cats in Categories
                where cats.CategoryID == categoryID
                select cats;
            return categoryQuery.Single().Name;
        }

        /// <summary>
        /// Gets the category ID value for the passed category name.
        /// </summary>
        /// <param name="categoryName">String: name of the category for which to pull the category ID.</param>
        /// <returns>Int: ID of the category for the specified category name.</returns>
        public int GetCategoryID(string categoryName)
        {
            IQueryable<Category> category =
                from cat in Categories
                where cat.Name == categoryName
                select cat;            
            return category.Single().CategoryID;            
        }

        /// <summary>
        /// Gets a list of string objects, each with a unique category name derived from the budget object that calls the method.
        /// </summary>
        /// <returns>List String: each string object returned represents a unique category.</returns>
        private List<string> GetCategoryNameList()
        {
            List<string> categories = new List<string>();

            IQueryable<Category> categoryQuery =
                from cats in Categories
                select cats;

            foreach (Category item in categoryQuery)
            {
                categories.Add(item.Name);
            }

            return categories;
        }        

        /// <summary>
        /// Gets the calling budget object's category table.
        /// </summary>
        /// <returns>Table Categor for the calling budget object.</returns>
        public Table<Category> GetCategoryTable()
        {
            return Categories;
        }

        /// <summary>
        /// Gets a list of categories based on the passed display type.
        /// </summary>
        /// <param name="displayed">Bool: dictates the displayed status.</param>
        /// <returns>List of string: list of categories by the displayed type dicated by the passed bool.</returns>
        public List<string> GetCategoryListByDisplay(bool displayed)
        {
            List<string> categories = new List<string>();
            IQueryable<Category> categoryQuery =
                from cats in Categories
                where cats.IsDisplayed == displayed
                select cats;

            foreach  (Category cat in categoryQuery)
            {
                categories.Add(cat.Name);
            }
            return categories;
        }

        /// <summary>
        /// Gets a list of string objects, each with a unique vendor name derived from the budget object that calls the method.
        /// </summary>
        /// <returns>List String: each string object returned represents a unique vendor.</returns>
        private List<string> GetVendorNameList()
        {
            List<string> vendors = new List<string>();

            IQueryable<Vendor> vendorQuery =
                from vend in Vendors
                select vend;

            foreach (Vendor item in vendorQuery)
            {
                vendors.Add(item.Name);
            }

            return vendors;
        }
     
        /// <summary>
        /// Gets the name of a vendor based on the passed vendor ID.
        /// </summary>
        /// <param name="vendorID">Int: vendor ID for which to pull the vendor name.</param>
        /// <returns>String: name of the vendor for the specified vendor ID.</returns>
        private string GetVendorName(int vendorID)
        {
            IQueryable<Vendor> vendorQuery =
                from vend in Vendors
                where vend.VendorID == vendorID
                select vend;
            return vendorQuery.Single().Name;
        }

        /// <summary>
        /// Infers if a passed entity name already exists in the calling budget. 
        /// </summary>
        /// <param name="catOrVend">String: Indication of the entity list to compare to. Either "Category" or "Vendor".</param>
        /// <param name="newName">String: new entity name being compared to the currently existing list.</param>
        /// <returns>Bool: True of the name already exists. False if the name does not already exist.</returns>
        public bool EntryNameExists(string catOrVend, string newName)
        {
            //Get a list of names from the appropriate table.
            List<string> names = new List<string>();
            if (catOrVend == "Vendor")
            {

                IQueryable<Vendor> nameCheckQuery =
                    from vends in Vendors
                    select vends;

                foreach (Vendor vend in nameCheckQuery)
                {
                    names.Add(Regex.Replace(vend.Name, "[^A-Za-z0-9]", "").ToUpper().Trim());
                }

            }
            else
            {
                IQueryable<Category> nameCheckQuery =
                    from cats in Categories
                    select cats;

                foreach (Category cats in nameCheckQuery)
                {
                    names.Add(Regex.Replace(cats.Name, "[^A-Za-z0-9]", "").ToUpper().Trim());
                }
            }

            //Compare the list to the new name.
            foreach (string formattedName in names)
            {
                if (formattedName == Regex.Replace(newName, "[^A-Za-z0-9]", "").ToUpper().Trim())
                {
                    MessageBox.Show("Name already exists.");
                    return true;
                }
            }

            //If still in the method, then the name is new.
            return false;
        }

        /// <summary>
        /// Gets the vendor ID value for the passed vendor name.
        /// </summary>
        /// <param name="vendorName">String: name of the vendor for which to pull the vendor ID.</param>
        /// <returns>Int: ID of the vendor for the specified vendor name.</returns>
        public int GetVendorID(string vendorName)
        {
            IQueryable<Vendor> vendor =
                from vend in Vendors
                where vend.Name == vendorName
                select vend;
            return vendor.Single().VendorID;
        }

        /// <summary>
        /// Gets the vendor table for the budget object calling the method.
        /// </summary>
        /// <returns>Table Vendor belonging to the calling budget object.</returns>
        public Table<Vendor> GetVendorTable()
        {
            return Vendors;
        }

        /// <summary>
        /// Infers if the passed entry's IsDefault field evaluates to true.
        /// </summary>
        /// <param name="catOrVend">String: Indication of the entity list to compare to. Either "Category" or "Vendor".</param>
        /// <param name="selectedName">String: entity name being reviewed for default status.</param>
        /// <returns>Bool: True if the entry is a default value. False if the entry is not a default value.</returns>
        internal bool IsDefaultEntry(string catOrVend, string selectedName)
        {
            //Get a list of default names from the appropriate table.
            List<string> names = new List<string>();
            if (catOrVend == "Vendor")
            {

                IQueryable<Vendor> nameCheckQuery =
                    from vends in Vendors
                    where vends.IsDefault == true
                    select vends;

                foreach (Vendor vend in nameCheckQuery)
                {
                    names.Add(Regex.Replace(vend.Name, "[^A-Za-z0-9]", "").ToUpper().Trim());
                }

            }
            else
            {
                IQueryable<Category> nameCheckQuery =
                    from cats in Categories
                    where cats.IsDefault == true
                    select cats;

                foreach (Category cats in nameCheckQuery)
                {
                    names.Add(Regex.Replace(cats.Name, "[^A-Za-z0-9]", "").ToUpper().Trim());
                }
            }

            //Compare the list to the new name.
            foreach (string formattedName in names)
            {
                if (formattedName == Regex.Replace(selectedName, "[^A-Za-z0-9]", "").ToUpper().Trim())
                {
                    MessageBox.Show("Name already exists.");
                    return true;
                }
            }

            //If still in the method, then the name is new.
            return false;
        }

        /// <summary>
        /// Fills a DGV object with transactions data.
        /// </summary>
        /// <param name="dgvTransactions">DataGridView object to fill with transactions data.</param>
        public void FillTransactionsDGV(DataGridView dgvTransactions)
        {
            dgvTransactions.DataSource = GetTransactionsList();
            dgvTransactions.AutoGenerateColumns = true;
        }

        /// <summary>
        /// Fills a DGV object with account information.
        /// </summary>
        /// <param name="dgvAccounts">DataGridView obgject to fill with account information.</param>
        public void FillAccountDGV(DataGridView dgvAccounts)
        {        
            dgvAccounts.DataSource = GetAccountListWithBalance();
            dgvAccounts.AutoGenerateColumns = true;
        }

        /// <summary>
        /// Fills a datagrid view with a list of entries (Vendors or Categories based on the parameter passed). Employed by the Category and Vendor manager.
        /// </summary>
        /// <param name="dgvSelectionList">DataGridView object to fill with entry information.</param>
        /// <param name="catOrVend">String: Indication of the type of entry list (Category or Vendor).</param>
        public void FillEditSelectionDGV(DataGridView dgvSelectionList, string catOrVend)
        {
            if (catOrVend == "Category")
            {
                List<Category> categories = new List<Category>();
                IQueryable<Category> categoriesQuery =
                    from cats in Categories
                    select cats;

                foreach (Category cat in categoriesQuery)
                {
                    Category nextCat = new Category();
                    nextCat.Name = cat.Name;
                    nextCat.IsDefault = cat.IsDefault;
                    categories.Add(nextCat);
                }
                
                dgvSelectionList.DataSource = categories;
            }
            else
            {
                List<Vendor> vendors = new List<Vendor>();
                IQueryable<Vendor> vendorsQuery =
                    from vends in Vendors
                    select vends;

                foreach (Vendor vend in vendorsQuery)
                {
                    Vendor nextVend = new Vendor();
                    nextVend.Name = vend.Name;
                    nextVend.IsDefault = vend.IsDefault;
                    vendors.Add(nextVend);
                }

                dgvSelectionList.DataSource = vendors;
            }

            dgvSelectionList.AutoGenerateColumns = true;
        }

        /// <summary>
        /// Fills a datagridview with spending by category information.
        /// </summary>
        /// <param name="dgvSpendingByCategory">DataGridView object to fill with spending by category information.</param>
        internal void FillSpendingByCategory(DataGridView dgvSpendingByCategory)
        {
            dgvSpendingByCategory.DataSource = GetSpendingByCategory();            
            dgvSpendingByCategory.AutoGenerateColumns = true;
        }

        /// <summary>
        /// Gets a list of TransactionsWithNames objects for the calling budget. Each object contains the details of a unique transaction.
        /// </summary>
        /// <returns>List TransactionsWithNames objects, each object contains the details of a unique transaction.</returns>
        private List<TransactionsWithNames> GetTransactionsList()
        {
            List<TransactionsWithNames> transactions = new List<TransactionsWithNames>();
            IQueryable<Transactions> transactionsQuery =
                from trans in Transactions
                select trans;

            foreach (Transactions item in transactionsQuery)
            {
                TransactionsWithNames itemToAdd = new TransactionsWithNames();
                itemToAdd.TransactionID = item.TransactionID;
                itemToAdd.TransactionDate = item.TransactionDate;
                itemToAdd.TransactionType = item.TransactionType;
                itemToAdd.Account = GetAccountName(item.AccountID);
                itemToAdd.Amount = item.Amount;
                itemToAdd.Category = GetCategoryName(item.CategoryID);
                itemToAdd.Vendor = GetVendorName(item.VendorID);
                itemToAdd.Description = item.Description;
                transactions.Add(itemToAdd);
            }
            return transactions;
        }

        /// <summary>
        /// Gets a list of SpendingByCategory objects for the calling budget. Each object contains the sum of spending for a specific category.
        /// </summary>
        /// <returns>List of SpendingByCategory objects, each object contains the sum of spending for a specific category.</returns>
        private List<SpendingByCategory> GetSpendingByCategory()
        {
            List<SpendingByCategory> categorySpending = new List<SpendingByCategory>();
            List<string> categories = GetCategoryListByDisplay(true);

            foreach (string category in categories)
            {
                SpendingByCategory categoryToAdd = new SpendingByCategory();
                categoryToAdd.CategoryID = GetCategoryID(category);
                categoryToAdd.Name = category;
                categoryToAdd.PriorMonth = GetCategoryTotal(categoryToAdd.CategoryID, DateTime.Now.AddMonths(-1));
                categoryToAdd.CurrentMonth = GetCategoryTotal(categoryToAdd.CategoryID, DateTime.Now);
                categoryToAdd.ThreeMonthAverage = GetCategoryThreeMonthAverage(categoryToAdd.CategoryID, DateTime.Now);
                categorySpending.Add(categoryToAdd);
            }
            return categorySpending;
        }

        /// <summary>
        /// Gets the total spending for a given category for the calling budget object.
        /// </summary>
        /// <param name="categoryID">Int: category ID for which to get total spending.</param>
        /// <param name="timeSpan">DateTime: time span in which to determine the total spending for a given category.</param>
        /// <returns>Decimal: total spending for the category for the specified timespan.</returns>
        private decimal GetCategoryTotal(int categoryID, DateTime timeSpan)
        {
            decimal total = 0;

            var categorySumQuery =
                from trans in Transactions
                where trans.CategoryID == categoryID && trans.TransactionDate.Month == timeSpan.Month && trans.TransactionDate.Year == timeSpan.Year
                select trans;

            foreach (var item in categorySumQuery)
            {
                total += item.Amount;
            }

            return total;
        }

        /// <summary>
        /// Gets the 3 month spending average for a given category for the calling budget object.
        /// </summary>
        /// <param name="categoryID">Int: category ID for which to get total spending.</param>
        /// <param name="originDate">DateTime: the data from which to count back 3 months in order to get prior three month average. Typically current date.</param>
        /// <returns>Decimal: average spending spending for the 3 months prior to the specified date.</returns>
        private decimal GetCategoryThreeMonthAverage(int categoryID, DateTime originDate)
        {
            decimal total = 0;

            var categorySumQuery =
                from trans in Transactions
                where trans.CategoryID == categoryID && (
                    trans.TransactionDate.Month == (originDate.AddMonths(-1).Month) && (trans.TransactionDate.Year == originDate.AddMonths(-1).Year)                
                    || trans.TransactionDate.Month == (originDate.AddMonths(-2).Month) && (trans.TransactionDate.Year == originDate.AddMonths(-2).Year)
                    || trans.TransactionDate.Month == (originDate.AddMonths(-3).Month) && (trans.TransactionDate.Year == originDate.AddMonths(-3).Year)
                )
                select trans;

            foreach (var item in categorySumQuery)
            {
                total += item.Amount;
            }

            return total/3;
        }
    }
}
