using System;
using System.Collections.Generic;
using System.Linq;
using System.Data.Linq.Mapping;
using System.Text;
using System.Threading.Tasks;
using System.IO;
using System.Data.Linq;
using System.Configuration;
using static BudgetAp.DatabaseInsertsAndMods;
using static BudgetAp.Utils;
using System.Data.SqlClient;
using System.Windows.Forms;
using System.Text.RegularExpressions;
using System.Security.Cryptography;
using System.Runtime.CompilerServices;
using BudgetAp.BudgetClasses.HelperBudgetClasses;

namespace BudgetAp.BudgetClasses
{
    public class BudgetDB
    {
        private DataContext db = new DataContext(ConfigurationManager.ConnectionStrings["BudgetConnect"].ConnectionString);
        private string backupLocation = "";
        private Table<Account> Accounts;
        private Table<Category> Categories;
        private Table<Vendor> Vendors;
        private Table<Transactions> Transactions;


        /// <summary>
        /// Budget class constructor.
        /// </summary>
        /// <param name="pathway">String: save location for the .bak file.</param>
        public BudgetDB(string pathway)
        {
            backupLocation = pathway;
            Accounts = db.GetTable<Account>();
            Categories = db.GetTable<Category>();
            Vendors = db.GetTable<Vendor>();
            Transactions = db.GetTable<Transactions>();

            if (Vendors.Count() == 0 && Categories.Count() == 0)
            {
                InsertDefaults();
            }
        }

        /// <summary>
        /// Provides the backup file location.
        /// </summary>
        /// <returns>String: backup file pathway.</returns>
        public string GetBackupLocation()
        {
            return backupLocation;
        }

        /// <summary>
        /// Inserts the default values for Vendors and Categories. Lists are found in the associated .txt files.
        /// </summary>
        private void InsertDefaults()
        {
            //Default vendors
            foreach (string item in GetListOfNames("vendor"))
            {
                AddVendor(Vendors, item, true);
            }

            //Default categories
            foreach (string item in GetListOfNames("category"))
            {
                AddCategory(Categories, item, true);
            }

            //Before submiting changes the vendor and cateogry object tables are not synced with the primary database. 
            db.SubmitChanges();
        }

        public bool IsSuccessfulNewAccount(string name, decimal balance, bool isAsset, bool isActive)
        {
            int accountID;

            //Confirm account doesn't already exist.
            if (AccountExists(name))
            {
                MessageBox.Show("Account already exists. Please modify the existing account or create a new account.", "New Account", MessageBoxButtons.OK, MessageBoxIcon.Information);
                return false;
            }

            //Add acount to account object
            AddAccount(Accounts, name, isAsset, isActive);

            //Submit to DB (IDs are auto generated by the DB upon submission of object level changes. Account ID is needed to insert the transaction.
            db.SubmitChanges();

            //Pull the newly created account ID          
            try
            {
                accountID = GetAccountID(name);
            }
            catch (InvalidOperationException exInvalid)
            {
                MessageBox.Show("Erorr! Account duplication in the database.");
                MessageBox.Show(exInvalid.ToString(), "New Account", MessageBoxButtons.OK, MessageBoxIcon.Information);
                return false; //TODO: confirm the return is necessary (i.e., does catching the exception end the program?)
            }
            catch (ArgumentNullException exNull)
            {
                MessageBox.Show("Error! Account not saved to the database.");
                MessageBox.Show(exNull.ToString(), "New Account", MessageBoxButtons.OK, MessageBoxIcon.Information);
                return false; //TODO: confirm the return is necessary (i.e., does catching the exception end the program?)
            }

            //Add a new account transaction.
            InsertTransaction(Transactions, DateTime.Now, accountID, GetNewAccountTransType(accountID), GetCategoryID("New Account Balance"), GetVendorID("N/A"), balance, "New Account");

            //Submit transaction to the DB.
            db.SubmitChanges();

            return true;
        }

        public int GetAccountCount()
        {
            IQueryable<Account> accountCount =
                from acct in Accounts
                select acct;
            return accountCount.Count();
        }

        private string GetAccountName(int accountID)
        {
            IQueryable<Account> account =
                from acct in Accounts
                where acct.AccountID == accountID
                select acct;
            return account.Single().Name;
        }

        private int GetAccountID(string accountName)
        {
            IQueryable<Account> account =
                from acct in Accounts
                where acct.Name == accountName
                select acct;
            return account.Single().AccountID;
        }

        private string GetNewAccountTransType(int accountID)
        {
            string transType;

            if (AccountIsAsset(accountID))
            {
                transType = "Payment To";
            }
            else
            {
                transType = "Payment From";
            }

            return transType;
        }

        private bool AccountIsAsset(int accountID)
        {
            IQueryable<Account> account =
                from acct in Accounts
                where acct.AccountID == accountID
                select acct;
            return account.Single().IsAsset;
        }

        private bool AccountExists(string accountName)
        {
            List<string> dbNames = new List<string>();
            IQueryable<Account> nameCheckQuery =
                from acct in Accounts
                select acct;

            foreach (Account item in nameCheckQuery)
            {
                dbNames.Add(Regex.Replace(item.Name, "[^A-Za-z0-9]", "").ToUpper().Trim());
            }

            foreach (string formattedName in dbNames)
            {
                if (formattedName == Regex.Replace(accountName, "[^A-Za-z0-9]", "").ToUpper().Trim())
                {
                    return true;
                }
            }

            //If still in the method, then the account is new.
            return false;
        }

        private decimal GetAccountBalance(int accountID)
        {
            //TODO: clean this up with a better use of LINQ (keep running into an issue with converting NULL to decimal (which shouldn't happen here anyways?).
            decimal from = 0;
            decimal to = 0;

            //Get total payments from the account.
            var accountBalanceFrom =
                  from trans in Transactions
                  where trans.AccountID == accountID && trans.TransactionType == "Payment From"
                  select trans;

            foreach (var account in accountBalanceFrom)
            {
                from += account.Amount;
            }

            //Get total payments to the account.
            var accountBalanceTo =
                from trans in Transactions
                where trans.AccountID == accountID && trans.TransactionType == "Payment To"
                select trans;

            foreach (var account in accountBalanceTo)
            {
                to += account.Amount;
            }

            //Determine asset status
            if (AccountIsAsset(accountID))
            {
                //Asset account balance is the sum of total payments to less payments from.
                return to - from;
            }
            else
            {
                //Liability account balance is the sum of payments from (i.e., credit to the holder) less payments to (i.e., paying down debt).
                return from - to;
            }
        }

        private string GetCategoryName(int categoryID)
        {
            IQueryable<Category> categoryQuery =
                from cats in Categories
                where cats.CategoryID == categoryID
                select cats;
            return categoryQuery.Single().Name;
        }

        private int GetCategoryID(string categoryName)
        {
            IQueryable<Category> category =
                from cat in Categories
                where cat.Name == categoryName
                select cat;
            return category.Single().CategoryID;

            //TODO: Try catch? Necessary? Shouldn't be if I'm propery catching during the insert phase.
        }

        private List<string> GetCategoryNameList()
        {
            List<string> categories = new List<string>();

            IQueryable<Category> categoryQuery =
                from cats in Categories
                select cats;

            foreach (Category item in categoryQuery)
            {
                categories.Add(item.Name);
            }

            return categories;
        }
     
        private string GetVendorName(int vendorID)
        {
            IQueryable<Vendor> vendorQuery =
                from vend in Vendors
                where vend.VendorID == vendorID
                select vend;
            return vendorQuery.Single().Name;
        }

        private int GetVendorID(string vendorName)
        {
            IQueryable<Vendor> vendor =
                from vend in Vendors
                where vend.Name == vendorName
                select vend;
            return vendor.Single().VendorID;

            //TODO: Try catch? Necessary? Shouldn't be if I'm propery catching during the insert phase.
        }

        public void FillTransactionsDGV(DataGridView dgvTransactions)
        {
            dgvTransactions.DataSource = GetTransactionsList();
            dgvTransactions.AutoGenerateColumns = true;
        }

        public void FillAccountDGV(DataGridView dgvAccounts)
        {
            //TODO: data binding, would that be the better choice?            
            dgvAccounts.DataSource = GetAccountList();

            //TODO: consider other formatting.
            dgvAccounts.AutoGenerateColumns = true;
        }

        internal void FillSpendingByCategory(DataGridView dgvSpendingByCategory)
        {
            dgvSpendingByCategory.DataSource = GetSpendingByCategory();            
            dgvSpendingByCategory.AutoGenerateColumns = true;
        }

        private List<AccountWithBalance> GetAccountList()
        {
            List<AccountWithBalance> accountList = new List<AccountWithBalance>();
            IQueryable<Account> accounts =
                from acct in Accounts
                select acct;

            foreach (Account item in accounts)
            {
                AccountWithBalance accountItem = new AccountWithBalance();
                accountItem.AccountID = item.AccountID;
                accountItem.Name = item.Name;
                accountItem.IsAsset = item.IsAsset;
                accountItem.IsActive = item.IsActive;
                accountItem.Balance = GetAccountBalance(item.AccountID);
                accountList.Add(accountItem);
            }

            return accountList;
        }

        private List<TransactionsWithNames> GetTransactionsList()
        {
            List<TransactionsWithNames> transactions = new List<TransactionsWithNames>();
            IQueryable<Transactions> transactionsQuery =
                from trans in Transactions
                select trans;

            foreach (Transactions item in transactionsQuery)
            {
                TransactionsWithNames itemToAdd = new TransactionsWithNames();
                itemToAdd.TransactionID = item.TransactionID;
                itemToAdd.TransactionDate = item.TransactionDate;
                itemToAdd.TransactionType = item.TransactionType;
                itemToAdd.Account = GetAccountName(item.AccountID);
                itemToAdd.Amount = item.Amount;
                itemToAdd.Category = GetCategoryName(item.CategoryID);
                itemToAdd.Vendor = GetVendorName(item.VendorID);
                itemToAdd.Description = item.Description;
                transactions.Add(itemToAdd);
            }
            return transactions;
        }

        private List<SpendingByCategory> GetSpendingByCategory()
        {
            List<SpendingByCategory> categorySpending = new List<SpendingByCategory>();
            List<string> categories = GetCategoryNameList();

            foreach (string category in categories)
            {
                SpendingByCategory categoryToAdd = new SpendingByCategory();
                categoryToAdd.CategoryID = GetCategoryID(category);
                categoryToAdd.Name = category;
                categoryToAdd.PriorMonth = GetCategoryTotal(categoryToAdd.CategoryID, DateTime.Now.AddMonths(-1));
                categoryToAdd.CurrentMonth = GetCategoryTotal(categoryToAdd.CategoryID, DateTime.Now);
                categoryToAdd.ThreeMonthAverage = GetCategoryThreeMonthAverage(categoryToAdd.CategoryID, DateTime.Now);
                categorySpending.Add(categoryToAdd);
            }
            return categorySpending;
        }

        private decimal GetCategoryTotal(int categoryID, DateTime timeSpan)
        {
            decimal total = 0;

            var categorySumQuery =
                from trans in Transactions
                where trans.CategoryID == categoryID && trans.TransactionDate.Month == timeSpan.Month && trans.TransactionDate.Year == timeSpan.Year
                select trans;

            foreach (var item in categorySumQuery)
            {
                total += item.Amount;
            }

            return total;
        }

        private decimal GetCategoryThreeMonthAverage(int categoryID, DateTime currentDate)
        {
            decimal total = 0;

            var categorySumQuery =
                from trans in Transactions
                where trans.CategoryID == categoryID && (
                    trans.TransactionDate.Month == (currentDate.AddMonths(-1).Month) && (trans.TransactionDate.Year == currentDate.AddMonths(-1).Year)                
                    || trans.TransactionDate.Month == (currentDate.AddMonths(-2).Month) && (trans.TransactionDate.Year == currentDate.AddMonths(-2).Year)
                    || trans.TransactionDate.Month == (currentDate.AddMonths(-3).Month) && (trans.TransactionDate.Year == currentDate.AddMonths(-3).Year)
                )
                select trans;

            foreach (var item in categorySumQuery)
            {
                total += item.Amount;
            }

            return total/3;
        }
    }
}
